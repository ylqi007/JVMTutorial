# Chapter 17. 垃圾回收器

## 17.1 GC分类与性能指标
* 垃圾收集器没有在规范中进行过多的规定，可以由不同的厂商、不同的版本的JVM来实现。
* 由于JDK的版本处于高速迭代过程中，因此Java发展至今已经衍生了众多的GC版本。
* 从不同角度分析垃圾回收器，可以将GC分为不同的类型。

Java不同版本新特性:
1. 语法层面: Lambda表达式，switch，自动装箱拆箱，enum。。。
2. API层面: 新旧API的变化，Stream API，新的日期时间，Optional，String，集合框架。。。
3. 底层优化: JVM的优化，GC的变化。。。

### 17.1.1 分类
#### 1. 按”线程数“分，可以分为串行垃圾回收器 and 并行垃圾回收器
* 串行回收指的是在同一时间段内只允许有一个CPU用于执行垃圾回收操作，此时工作线程被暂停，直至垃圾收集工作结束。
  * 在诸如单CPU处理器或者较小的应用内存等硬件平台并不是特别优越的场合，串行回收器的性能表现可以超过并行回收器和并发回收器。所以，串行回收默认被应用在客户端的Client模式下的JVM中。
  * 在并发能力比较强的CPU上，并行回收器产生的停顿时间要短于串行回收器。
* 和串行回收想法，并行收集可以运用多个CPU同时执行垃圾回收，因此提升了应用的吞吐量。
* 不过，并行回收仍然与串行回收一样，采用独占式，使用了"Stop-the-World"机制。

#### 2. 按照工作模式分，并发式垃圾回收器和独占式垃圾回收器
* 并发式垃圾回收器与应用程序交替工作，以尽可能减少应用程序的停顿时间。
* 独占式垃圾回收器(Stop to World)一旦运行，就停止应用程序中的所有用户线程，直到垃圾回收过程完全结束。

#### 3. 按碎片处理方式，压缩式垃圾回收器和非压缩式垃圾回收器
* 压缩式垃圾回收器会在完成回收之后，对存活的对象进行压缩整理，消除回收后的碎片。
  * 再分配对象空间使用：指针碰撞
* 非压缩式的垃圾回收器不进行这步。
  * 再分配对象空间使用：空闲列表

#### 4. 按工作的内存区间分，年轻代垃圾回收器和老年代垃圾回收器

### 17.1.2 性能指标
* **吞吐量**: 运行用户代码的时间占总运行时间的比例。
  * 总运行时间: 程序的运行时间+内存回收的时间
* 垃圾收集开销: 吞吐量的补数，垃圾收集所用时间与总运行时间的比例。
* **暂停时间**: 执行垃圾收集时，程序的工作线程被暂停的时间。
* 收集频率: 相对于应用程序的执行，收集操作发生的频率。
* **内存占用**: Java堆区所占的内存大小。
* 快速: 一个对象从诞生到被回收所经历的时间。

1. 以上黑体字的三者构成了一个"不可能"三角。三者总体的表现会随着技术进步越来越好。一款优秀的收集器通常最多同时满足其中的两项。
2. 这三项里，暂停时间的重要性日渐凸显。因为随着硬件发展，内存占用多些越来越能容忍，硬件性能的提升也有助于降低收集器运行时对应用程序的影响，即提高了吞吐量。而内存的扩大，对延迟反而带来负面效果。
3. 简单来说，主要抓住两点:
   1. 吞吐量
   2. 暂停时间

#### 1. 吞吐量
吞吐量就是CPU用于用户代码的时间与CPU总消耗时间的比值，即吞吐量=运行用户代码时间/(运行用户代码时间 + 垃圾收集时间)


#### 2. 暂停时间


## 17.2 不同的垃圾回收器概述
垃圾收集机制时Java的招牌能力，极大地提高了开发效率。这也是面试的热点。

### 17.2.1 垃圾收集器发展史 
#### 1. 7款经典的垃圾收集器
* 串行回收器: Serial, Serial Old
* 并行回收器: ParNew, Parallel Scavenge, Parallel Old
* 并发回收器: CMS, G1

#### 2. 如何查看默认的垃圾回收器
* `-XX:+PrintCommandLineFlags`: 查看命令行相关参数
* 使用命令行指令: `jinfo -flag<相关垃圾回收器参数> <进程ID>`
* Example: `com.atguigu.java.GCUseTest`

## 17.3 Serial回收器: 串行回收
## 17.4 ParNew回收器: 并行回收
## 17.5 Parallel回收器: 吞吐量优先
## 17.6 CMS回收器: 低延迟
## 17.7 G1回收器: 区域化分代式
## 17.8 垃圾回收器总结
## 17.9 GC日志分析
## 17.10 垃圾回收器的新发展
